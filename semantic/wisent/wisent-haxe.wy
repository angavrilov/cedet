;;; wisent-haxe.wy -- LALR grammar for Haxe
;;
;; Copyright (C) 2009 Alexander Gavrilov
;;
;; Based on javascript parser
;; Copyright (C) 2005 Joakim Verona, Eric Ludlam
;; JAVE Copyright (C) Alex Walker
;;
;; Maintainer:
;; Keywords: syntax
;; X-RCS: $Id: wisent-haxe.wy,v 1.1 2008/09/04 01:58:56 zappo Exp $
;;
;; This file is not part of GNU Emacs.
;;
;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation; either version 2, or (at
;; your option) any later version.
;;
;; This software is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING.  If not, write to the
;; Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
;; Boston, MA 02110-1301, USA.
;;
;;; Commentary:
;;

%package wisent-haxe-wy
%languagemode haxe-mode

;; The default goal
%start compilation_unit
;; Other Goals
%start class_member_declaration
%start interface_member_declaration
%start formal_parameter_item
%start array_ref_item
%start comma_expressions_item

;; with the terminals stuff, I used the javacript.y names,
;; but the wisent-java-tags.wy types
;; when possible
;; ------------------
;; Operator terminals
;; ------------------

;;define-lex-string-type-analyzer gets called with the "syntax" comment
%type <punctuation> ;;syntax "\\(\\s.\\|\\s$\\|\\s'\\)+" matchdatatype string

%token <punctuation> SHARP                    "#"
%token <punctuation> ARROW                    "->"
%token <punctuation> ASSIGN_SYMBOL            "="
%token <punctuation> BITWISE_AND              "&"
%token <punctuation> BITWISE_AND_EQUALS       "&="
%token <punctuation> BITWISE_EXCLUSIVE_OR     "^"
%token <punctuation> BITWISE_EXCLUSIVE_OR_EQUALS "^="
%token <punctuation> BITWISE_OR               "|"
%token <punctuation> BITWISE_OR_EQUALS        "|="
%token <punctuation> BITWISE_SHIFT_LEFT       "<<"
%token <punctuation> BITWISE_SHIFT_LEFT_EQUALS "<<="
;;%token <punctuation> BITWISE_SHIFT_RIGHT      ">>"
%token <punctuation> BITWISE_SHIFT_RIGHT_EQUALS ">>="
;;%token <punctuation> BITWISE_SHIFT_RIGHT_ZERO_FILL ">>>"
%token <punctuation> BITWISE_SHIFT_RIGHT_ZERO_FILL_EQUALS ">>>="
%token <punctuation> NOT_EQUAL "!="
%token <punctuation> DIV_EQUALS "/="
%token <punctuation> EQUALS "=="
%token <punctuation> GREATER_THAN ">"
%token <punctuation> GT_EQUAL ">="
%token <punctuation> LOGICAL_AND "&&"
%token <punctuation> LOGICAL_OR "||"
%token <punctuation> LOGICAL_NOT "!!"
%token <punctuation> LS_EQUAL "<="
%token <punctuation> MINUS "-"
%token <punctuation> MINUS_EQUALS "-="
%token <punctuation> MOD "%"
%token <punctuation> MOD_EQUALS "%="
%token <punctuation> MULTIPLY "*"
%token <punctuation> MULTIPLY_EQUALS "*="
%token <punctuation> PLUS "+"
%token <punctuation> PLUS_EQUALS "+="
%token <punctuation> INCREMENT "++"
%token <punctuation> DECREMENT "--"
%token <punctuation> DIV "/"
%token <punctuation> COLON ":"
%token <punctuation> COMMA ","
%token <punctuation> DOT "."
%token <punctuation> RANGE_ITERATOR "..."
%token <punctuation> LESS_THAN "<"
%token <punctuation> LINE_TERMINATOR "\n"
%token <punctuation> SEMICOLON ";"
%token <punctuation> ONES_COMPLIMENT "~"
%token <punctuation> QUESTION "?"


;; -----------------------------
;; Block & Parenthesis terminals
;; -----------------------------
%type  <block>       ;;syntax "\\s(\\|\\s)" matchdatatype block
%token <block>       PAREN_BLOCK "(OPEN_PARENTHESIS CLOSE_PARENTHESIS)"
%token <block>       BRACE_BLOCK "(LBRACE RBRACE)"
%token <block>       BRACK_BLOCK "(OPEN_SQ_BRACKETS CLOSE_SQ_BRACKETS)"

%token <open-paren>  OPEN_PARENTHESIS  "("
%token <close-paren>  CLOSE_PARENTHESIS ")"

%token <open-paren>  LBRACE       "{"
%token <close-paren>  RBRACE         "}"

%token <open-paren>  OPEN_SQ_BRACKETS  "["
%token <close-paren>  CLOSE_SQ_BRACKETS "]"


;; -----------------
;; Keyword terminals
;; -----------------

;; Generate a keyword analyzer
%type  <keyword> ;;syntax "\\(\\sw\\|\\s_\\)+" matchdatatype keyword

%keyword IMPORT       "import"
%put     IMPORT summary
"Import package declarations: import <package>"

%keyword USING        "using"
%put     USING summary
"Load a method mixin package: using <class>"

%keyword PACKAGE      "package"
%put     PACKAGE summary
"Package declaration: package <name>"

%keyword CLASS        "class"
%put     CLASS summary
"Class declaration: class <name>"

%keyword INTERFACE    "interface"
%put     INTERFACE summary
"Interface declaration: interface <name>"


%keyword IMPLEMENTS   "implements"
%put     IMPLEMENTS summary
"Class SuperInterfaces declaration: implements <name> [, ...]"

%keyword EXTENDS      "extends"
%put     EXTENDS summary
"SuperClass|SuperInterfaces declaration: extends <name> [, ...]"

%keyword PRIVATE      "private"
%put     PRIVATE summary
"Access level modifier: private {class|interface|<type>} <name> ..."

%keyword PUBLIC       "public"
%put     PUBLIC summary
"Access level modifier: public {class|interface|<type>} <name> ..."

%keyword STATIC       "static"
%put     STATIC summary
"Declaration modifier: static {class|interface|<type>} <name> ..."

%keyword INLINE       "inline"
%put     INLINE summary
"Declaration modifier: inline {method} <name> ..."

%keyword OVERRIDE     "override"
%put     OVERRIDE summary
"Declaration modifier: override {method} <name> ..."

%keyword DYNAMIC      "dynamic"
%put     DYNAMIC summary
"Declaration modifier: dynamic {method} <name> ..."


%keyword IF           "if"
%put     IF summary
"if (<expr>) <stmt> [else <stmt>] (jv)"

%keyword END           "end"
%put     END summary
"end"

%keyword BREAK        "break"
%put     BREAK summary
"break [<label>] ;"

%keyword CONTINUE     "continue"
%put     CONTINUE summary
"continue [<label>] ;"

%keyword ELSE         "else"
%put     ELSE summary
"if (<expr>) <stmt> else <stmt>"


%keyword FOR          "for"
%put     FOR summary
"for ([<init-expr>]; [<expr>]; [<update-expr>]) <stmt>"


%keyword FUNCTION  "function"
%put     FUNCTION summary
"function declaration blah blah"

%keyword THIS         "this"
%put THIS summary
"this"

%keyword TRUE         "true"
%put TRUE summary
"true"

%keyword FALSE        "false"
%put FALSE summary
"false"

%keyword RETURN       "return"
%put     RETURN summary
"return [<expr>] ;"

%keyword WHILE        "while"
%put     WHILE summary
"while (<expr>) <stmt> | do <stmt> while (<expr>);"

%keyword VOID_SYMBOL         "void"
%put     VOID_SYMBOL summary
"Method return type: void <name> ..."



%keyword NEW          "new"
%put NEW summary
"new <objecttype> - Creates a new object."

%keyword DELETE "delete"
%put DELETE summary
"delete(<objectreference>) - Deletes the object."

%keyword VAR "var"
%put VAR  summary
"var <variablename> [= value];"

%keyword WITH "with"
%put WITH summary
"with "

%keyword TYPEOF "typeof"
%put TYPEOF summary
"typeof "

%keyword IN "in"
%put IN  summary
"in something"


;; -----------------
;; Literal terminals
;; -----------------

;;the .y file uses IDENTIFIER as IDENTIFIER, which seems a bit evil
;; it think the normal .wy convention is better than this
%type  <symbol>      ;;syntax "\\(\\sw\\|\\s_\\)+"
%token <symbol>      IDENTIFIER

%type  <string>      ;;syntax "\\s\"" matchdatatype sexp
%token <string>      STRING

%type  <number>      ;;syntax semantic-lex-number-expression
%token <number>      NUMBER



%token NULL_TOKEN

;;%token UNDEFINED_TOKEN
;;%token INFINITY

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; associativity and stuff
%right ARROW

%right ASSIGN_SYMBOL
%right QUESTION
%left LOGICAL_OR
%left LOGICAL_AND
%nonassoc RANGE_ITERATOR
%left EQUALS NOT_EQUAL
%left GREATER_THAN LESS_THAN LS_EQUAL GT_EQUAL
%left BITWISE_EXCLUSIVE_OR BITWISE_OR
%left BITWISE_AND
%left BITWISE_SHIFT_LEFT ;; BITWISE_SHIFT_RIGHT
%left PLUS MINUS
%left MULTIPLY DIV
%left MOD

%nonassoc FALSE
%nonassoc HIGHER_THAN_FALSE
%nonassoc ELSE
%nonassoc LOWER_THAN_CLOSE_PARENTHESIS
%nonassoc CLOSE_PARENTHESIS

%%

;;; TOPLEVEL
compilation_unit
  : package_declaration
  | import_declaration
  | preprocessor_element
  | type_declaration
  ;

;;; Package statement token
;; ("NAME" package DETAIL "DOCSTRING")
package_declaration
  : PACKAGE qualified_name SEMICOLON
    (PACKAGE-TAG $2 nil)
  ;

;;; Include file token
;; ("FILE" include SYSTEM "DOCSTRING") 
import_declaration
  : IMPORT qualified_name SEMICOLON
    (INCLUDE-TAG $2 nil)
  | USING qualified_name SEMICOLON
    (INCLUDE-TAG $2 nil :using-mixin t)
  | IMPORT qualified_name DOT MULTIPLY SEMICOLON
    (INCLUDE-TAG (concat $2 $3 $4) nil)
  ;

type_declaration
  : SEMICOLON
    ()
  | class_declaration
  | interface_declaration
  ;

;;; MISC
qualified_name_list
  : qualified_name_list COMMA qualified_name
    (cons $3 $1)
  | qualified_name
    (list $1)
  ;

qualified_name
  : qualified_name DOT IDENTIFIER
    (concat $1 $2 $3)
  | IDENTIFIER
  ;

preprocessor_element : SHARP IF IDENTIFIER
                     | SHARP IF PAREN_BLOCK
                     | SHARP ELSE
                     | SHARP END
                     ;

;;; CLASS

;;; Type Declaration token
;; ("NAME" type "TYPE" ( PART-LIST ) ( PARENTS ) EXTRA-SPEC "DOCSTRING")
class_declaration
  : modifiers_opt CLASS qualified_name type_args_opt parent_list class_body
    (TYPE-TAG $3 $2 $6 $5 :typemodifiers $1 :template-specifier $4)
  ;

interface_declaration
  : modifiers_opt INTERFACE qualified_name type_args_opt parent_list interface_body
    (TYPE-TAG $3 $2 $6 $5 :typemodifiers $1 :template-specifier $4)
  ;

parent_list
  : ;;EMPTY
    nil
  | EXTENDS qualified_name
    (cons $2 nil)
  | IMPLEMENTS qualified_name
    (cons nil (list $2))
  | parent_list COMMA IMPLEMENTS qualified_name
    (cons (car $1) (cons $4 (cdr $1)))
  ;

modifiers_opt
  : ;;EMPTY
  | modifiers
    (nreverse $1)
  ;

modifiers
  : modifiers modifier
    (cons $2 $1)
  | modifier
    (list $1)
  ;

modifier
  : STATIC
  | PRIVATE
  | PUBLIC
  | INLINE
  | OVERRIDE
  | DYNAMIC
  ;

class_body
  : BRACE_BLOCK
    (EXPANDFULL $1 class_member_declaration)
  ;

interface_body
  : BRACE_BLOCK
    (EXPANDFULL $1 interface_member_declaration)
  ;

class_member_declaration
  : LBRACE
    ()
  | RBRACE
    ()
  | constructor_declaration
  | method_declaration
  | field_declaration
  | preprocessor_element
  ;

interface_member_declaration
  : LBRACE
    ()
  | RBRACE
    ()
  | interface_method_declaration
  | field_declaration
  | preprocessor_element
  ;

field_declaration : modifiers_opt VAR IDENTIFIER property_def_opt COLON type_specifier initializer_opt SEMICOLON
                    (VARIABLE-TAG $3 $6 $7 :typemodifiers $1 :property-spec $4)
                  | modifiers_opt VAR IDENTIFIER property_def_opt initializer SEMICOLON
                    (VARIABLE-TAG $3 nil $5 :typemodifiers $1 :property-spec $4)
                  ;

property_def_opt : ;; EMPTY
                 | PAREN_BLOCK
                 ;

method_declaration : modifiers_opt FUNCTION IDENTIFIER type_args_opt formal_parameter_list_block type_specifier_opt Block
                     (FUNCTION-TAG $3 $6 $5 :typemodifiers $1 :template-specifier $4)
                   ;

interface_method_declaration : modifiers_opt FUNCTION IDENTIFIER type_args_opt formal_parameter_list_block type_specifier_opt SEMICOLON
                     (FUNCTION-TAG $3 $6 $5 :typemodifiers $1 :template-specifier $4)
                   ;

constructor_declaration : modifiers_opt FUNCTION NEW formal_parameter_list_block type_specifier_opt Block
                          (FUNCTION-TAG $3 $5 $4 :typemodifiers $1 :constructor-flag t)
                        ;

;;; TYPES
type_specifier_list
  : type_specifier_list COMMA type_specifier
    (concat $1 $2 $3)
  | type_specifier
    (identity $1)
  ;

type_specifier_opt : ;; EMPTY
                   | COLON type_specifier
                     (identity $2)
                   ;

type_specifier : qualified_name type_args_opt
                 (concat $1 $2)
               | type_specifier ARROW type_specifier
                 (concat $1 $2 $3)
               ;

type_args_opt : ;; EMPTY
                (identity "")
              | LESS_THAN type_specifier_list GREATER_THAN
                (concat $1 $2 $3)
              ;

;;; CODE

formal_parameter_list_block : PAREN_BLOCK
                              (EXPANDFULL $1 formal_parameter_item)
                            ;

formal_parameter_item: OPEN_PARENTHESIS
                       ()
                     | IDENTIFIER type_specifier_opt
                       (VARIABLE-TAG $1 $2 nil)
                     | QUESTION IDENTIFIER type_specifier_opt initializer_opt
                       (VARIABLE-TAG $2 $3 (or $4 "null"))
                     | CLOSE_PARENTHESIS
                       ()
                     | COMMA
                       ()
                     | preprocessor_element
                     ;

initializer_opt : ;; EMPTY
                | initializer
                ;

initializer : ASSIGN_SYMBOL one_expression
	      (identity $2)
            ;

StatementList : Statement
              | StatementList Statement
              ;

Statement : Block
          | VariableStatement
          | EmptyStatement
          | ExpressionStatement
          | IfStatement
          | IterationExpression
          | ContinueStatement
          | BreakStatement
          | ReturnStatement
          | WithStatement
          ;

Block : BRACE_BLOCK
     ;; If you want to parse the body of the function
     ;; ( EXPANDFULL $1 BlockExpand )
      ;

BlockExpand: LBRACE StatementList RBRACE
	   | LBRACE RBRACE
	   ;

VariableStatement : VAR VariableDeclarationList SEMICOLON
		    (VARIABLE-TAG $2 nil nil)
                  ;

VariableDeclarationList : VariableDeclaration
			  (list $1)
                        | VariableDeclarationList COMMA VariableDeclaration
			  (append $1 (list $3))
                        ;

VariableDeclaration : IDENTIFIER
		      (append (list $1 nil) $region)
                    | IDENTIFIER initializer
		      (append (list $1 $2) $region)
                    ;

EmptyStatement : SEMICOLON
               ;

ExpressionStatement : Expression SEMICOLON
                    ;

IfStatement : IF OPEN_PARENTHESIS Expression CLOSE_PARENTHESIS Statement  %prec HIGHER_THAN_FALSE
            | IF OPEN_PARENTHESIS Expression CLOSE_PARENTHESIS Statement ELSE Statement
            | IF OPEN_PARENTHESIS FALSE CLOSE_PARENTHESIS Statement
            | IF OPEN_PARENTHESIS reference_expression AssignmentOperator one_expression CLOSE_PARENTHESIS Statement
            ;

IterationExpression : WHILE OPEN_PARENTHESIS Expression CLOSE_PARENTHESIS Statement %prec HIGHER_THAN_FALSE
                    | WHILE OPEN_PARENTHESIS FALSE CLOSE_PARENTHESIS Statement
                    | WHILE OPEN_PARENTHESIS reference_expression AssignmentOperator one_expression CLOSE_PARENTHESIS Statement
                    | FOR OPEN_PARENTHESIS OptionalExpression SEMICOLON OptionalExpression SEMICOLON OptionalExpression CLOSE_PARENTHESIS Statement
                    | FOR OPEN_PARENTHESIS VAR VariableDeclarationList SEMICOLON OptionalExpression SEMICOLON OptionalExpression CLOSE_PARENTHESIS Statement
                    | FOR OPEN_PARENTHESIS reference_expression IN Expression CLOSE_PARENTHESIS Statement
                    | FOR OPEN_PARENTHESIS VAR IDENTIFIER initializer_opt IN Expression CLOSE_PARENTHESIS Statement
                    ;

ContinueStatement : CONTINUE SEMICOLON
                  ;

;;JAVE break needs labels 
BreakStatement : BREAK SEMICOLON
              ;;               | BREAK identifier SEMICOLON
               ;

ReturnStatement : RETURN Expression SEMICOLON
                | RETURN SEMICOLON
                ;

WithStatement : WITH OPEN_PARENTHESIS Expression CLOSE_PARENTHESIS   Statement
              ;

actual_argument_list : PAREN_BLOCK
                       ( EXPANDFULL $1 comma_expressions_item )
                     ;

array_ref_op : BRACK_BLOCK
               ( EXPANDFULL $1 array_ref_item )
             ;

array_ref_item: OPEN_SQ_BRACKETS one_expression CLOSE_SQ_BRACKETS
              ;

reference_expression : THIS
                     | IDENTIFIER
                     | atomic_expression DOT IDENTIFIER
                     ;

atomic_expression : NUMBER
                  | STRING
                  | NULL_TOKEN
                  | TRUE
                  | FALSE
                  | PAREN_BLOCK
                    ( EXPANDFULL $1 comma_expressions_item )
                  | BRACK_BLOCK
                    ( EXPANDFULL $1 comma_expressions_item )
                  | BRACE_BLOCK
                  | reference_expression
                  | NEW qualified_name type_args_opt actual_argument_list
                  | atomic_expression actual_argument_list
                  | atomic_expression array_ref_op
                  ;

post_unary_expression : atomic_expression
                      | post_unary_expression INCREMENT
                      | post_unary_expression DECREMENT
                      ;

unary_expression : post_unary_expression
                 | DELETE unary_expression
                 | VOID_SYMBOL unary_expression
                 | TYPEOF unary_expression
                 | INCREMENT unary_expression
                 | DECREMENT unary_expression
                 | PLUS unary_expression
                 | MINUS unary_expression
                 | ONES_COMPLIMENT unary_expression
                 | LOGICAL_NOT unary_expression
                 ;

one_expression : unary_expression
               | one_expression MULTIPLY one_expression
               | one_expression DIV one_expression
               | one_expression MOD one_expression
               | one_expression PLUS one_expression
               | one_expression MINUS one_expression
               | one_expression BITWISE_SHIFT_LEFT one_expression
              ;; | one_expression BITWISE_SHIFT_RIGHT one_expression
               | one_expression LESS_THAN one_expression
               | one_expression GREATER_THAN one_expression
               | one_expression GREATER_THAN GREATER_THAN one_expression
               | one_expression GREATER_THAN GREATER_THAN GREATER_THAN one_expression
               | one_expression LS_EQUAL one_expression
               | one_expression GT_EQUAL one_expression
               | one_expression EQUALS one_expression
               | one_expression NOT_EQUAL one_expression
               | one_expression BITWISE_AND one_expression
               | one_expression BITWISE_EXCLUSIVE_OR one_expression
               | one_expression BITWISE_OR one_expression
               | one_expression LOGICAL_AND one_expression
               | one_expression LOGICAL_OR one_expression
               | one_expression QUESTION one_expression COLON one_expression %prec QUESTION
               | reference_expression AssignmentOperator one_expression %prec ASSIGN_SYMBOL
               ;

AssignmentOperator : ASSIGN_SYMBOL
                   | MULTIPLY_EQUALS
                   | DIV_EQUALS
                   | MOD_EQUALS
                   | PLUS_EQUALS
                   | MINUS_EQUALS
                   | BITWISE_SHIFT_LEFT_EQUALS
                   | BITWISE_SHIFT_RIGHT_EQUALS
                   | BITWISE_SHIFT_RIGHT_ZERO_FILL_EQUALS
                   | BITWISE_AND_EQUALS
                   | BITWISE_EXCLUSIVE_OR_EQUALS
                   | BITWISE_OR_EQUALS
                   ;

Expression : one_expression
           | Expression COMMA one_expression
           ;

comma_expressions_item: OPEN_PARENTHESIS
                        ()
                      | OPEN_SQ_BRACKETS
                        ()
                      | one_expression
                      | CLOSE_SQ_BRACKETS
                        ()
                      | CLOSE_PARENTHESIS
                        ()
                      | COMMA
                        ()
                      ;


OptionalExpression : Expression
                   |
                   ;

%%

;;here something like:
;;(define-lex wisent-java-tags-lexer
;; should go
(define-lex haxe-lexer
"haxe thingy"
;;std stuff
  semantic-lex-ignore-whitespace
  semantic-lex-ignore-newline
  semantic-lex-ignore-comments

  ;;stuff generated from the wy file(one for each "type" declaration)
  wisent-haxe-wy--<number>-regexp-analyzer
  wisent-haxe-wy--<string>-sexp-analyzer

  wisent-haxe-wy--<keyword>-keyword-analyzer

  wisent-haxe-wy--<symbol>-regexp-analyzer
  wisent-haxe-wy--<punctuation>-string-analyzer
  wisent-haxe-wy--<block>-block-analyzer


  ;;;;more std stuff
  semantic-lex-default-action
  )
